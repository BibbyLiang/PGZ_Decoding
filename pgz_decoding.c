#include <stdio.h>
#include <string.h>
#include "pgz_decoding.h"

unsigned char power_polynomial_table[GF_FIELD][2] = 
{
	/*power <---> polynomial*/
	/*These are also the coefficients of generator polynomials.*/
	{0xFF, 0x0},
	{0x0, 0x1},
	{0x1, 0x2},
	{0x2, 0x4},
	{0x3, 0x3},
	{0x4, 0x6},
	{0x5, 0x7},
	{0x6, 0x5}
};

unsigned char generator_polynomial[CODEWORD_LEN - MESSAGE_LEN + 1] =
{
	/*generated by MATLAB: genpoly = rsgenpoly(n, k, prim_poly)*/
	0x3,
	0x1,
	0x0,
	0x3,
	0x1
};

unsigned char message_polynomial[MESSAGE_LEN] = 
{
	/*power representation*/
	0xFF,
	0x1,
	0xFF
};

unsigned char received_polynomial[CODEWORD_LEN] =
{
	0x0,
	0x4,
	0x2,
	0x2,
	0x4,
	0x1,
	0xFF
};

unsigned char gf_pow2poly(unsigned char val_in_pow)
{
	unsigned char val_in_poly = 0;

	return power_polynomial_table[val_in_pow + 1][1];
}

unsigned char gf_poly2pow(unsigned char val_in_poly)
{
	unsigned char i = 0;
	unsigned char val_in_pow = 0;

	for(i = 0; i < GF_FIELD; i++)
	{
		if(power_polynomial_table[i][1] == val_in_poly)
		{
			val_in_pow = power_polynomial_table[i][0];
			break;
		}
	}

	return val_in_pow;
}

unsigned char gf_location(unsigned char val)
{
	unsigned char val_location = power_polynomial_table[val + 1][0];

	return val_location;
}

unsigned char gf_add(unsigned char a, unsigned char b)
{
	unsigned char i = 0;
	unsigned char sum_in_pow = 0;
	
	unsigned char sum_in_poly = gf_pow2poly(a) ^ gf_pow2poly(b);
	sum_in_pow = gf_poly2pow(sum_in_poly);

	return sum_in_pow;
}

unsigned char gf_multp(unsigned char a, unsigned char b)
{
	if((0xFF == a) || (0xFF == b))
	{
		return 0xFF;
	}

	unsigned char product_in_pow = (a + b) % (GF_FIELD - 1);

	return product_in_pow;
}

unsigned char gf_div(unsigned char a, unsigned char b)
{
	if(0xFF == a)
	{
		return 0xFF;
	}
	if(0xFF == b)
	{
		printf("div err.\n");
		return 0xFF;
	}

	unsigned char quotient_in_pow = (a - b) % (GF_FIELD - 1);

	return quotient_in_pow;
}

unsigned char gf_mod_single_term(unsigned char a, unsigned char b)
{
	unsigned char remainder_in_pow = 0xFF;
	if(a >= b)
	{
		remainder_in_pow = 0xFF;
	}
	else
	{
		remainder_in_pow = a;
	}

	return remainder_in_pow;
}

int pgz_decoding()
{
	unsigned char i = 0, j = 0, tmp = 0xFF, tmp_sum = 0xFF, lambda_root = 0;
	unsigned char syndrome[CODEWORD_LEN - MESSAGE_LEN];
	unsigned char lambda[(CODEWORD_LEN - MESSAGE_LEN) / 2 + 1];
	unsigned char omega[(CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN)];
	unsigned char omega_tmp[(CODEWORD_LEN - MESSAGE_LEN) / 2 + 1][(CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1)];
	unsigned char err_location[CODEWORD_LEN];
	unsigned char lambda_dev[(CODEWORD_LEN - MESSAGE_LEN) / 2];
	unsigned char err_mag[CODEWORD_LEN];
	memset(syndrome, 0xFF, sizeof(unsigned char) * (CODEWORD_LEN - MESSAGE_LEN));
	memset(lambda, 0x0, sizeof(unsigned char) * ((CODEWORD_LEN - MESSAGE_LEN) / 2 + 1));
	memset(omega, 0xFF, sizeof(unsigned char) * ((CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1)));
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + 1; i++)
	{
		for(j = 0; j < (CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1); j++)
		{
			omega_tmp[i][j] = 0xFF;
		}
	}
	memset(err_location, 0x0, sizeof(unsigned char) * CODEWORD_LEN);
	memset(lambda_dev, 0xFF, sizeof(unsigned char) * ((CODEWORD_LEN - MESSAGE_LEN) / 2));
	memset(err_mag, 0xFF, sizeof(unsigned char) * CODEWORD_LEN);

	/*compute the syndrome polynomial from received symbols*/
	for(i = 0; i < CODEWORD_LEN - MESSAGE_LEN; i++)
	{
		tmp = 0xFF;
		tmp_sum = 0xFF;
		for(j = 0; j < CODEWORD_LEN; j++)
		{
			tmp = gf_multp(received_polynomial[j], (i + 1) * j);
			tmp_sum = gf_add(tmp, tmp_sum);
			//printf("%x %x\n", tmp, tmp_sum);
		}
		syndrome[i] = tmp_sum;
	}
	printf("Syndrome Polynomial:\n");
	for(i = 0; i < CODEWORD_LEN - MESSAGE_LEN; i++)
	{
		printf("%x ", syndrome[i]);
	}
	printf("\n");

	lambda[1] = gf_div(gf_add(gf_multp(syndrome[2], syndrome[1]), gf_multp(syndrome[0], syndrome[3])),
						gf_add(gf_multp(syndrome[1], syndrome[1]), gf_multp(syndrome[0], syndrome[2])));
	lambda[2] = gf_div(gf_add(gf_multp(syndrome[2], syndrome[2]), gf_multp(syndrome[1], syndrome[3])),
						gf_add(gf_multp(syndrome[1], syndrome[1]), gf_multp(syndrome[0], syndrome[2])));

	printf("Lambda Polynomial:\n");
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + 1; i++)
	{
		printf("%x ", lambda[i]);
	}
	printf("\n");

	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + 1; i++)
	{
		for(j = 0; j < CODEWORD_LEN - MESSAGE_LEN; j++)
		{
			omega_tmp[i][j] = gf_multp(lambda[i], syndrome[j]);
			//printf("%d %d: %x %x %x\n", i, j, lambda[i], syndrome[j], omega_tmp[i][j]);
		}
	}
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + 1; i++)
	{
		for(j = 0; j < CODEWORD_LEN - MESSAGE_LEN; j++)
		{
			omega[i + j] = gf_add(omega[i + j], omega_tmp[i][j]);
		}
	}

	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1) / 2 + 1; i++)
	{
		omega[i] = gf_mod_single_term(omega[i], CODEWORD_LEN - MESSAGE_LEN);
	}
	printf("Omega Polynomial:\n");
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1) / 2 + 1; i++)
	{
		printf("%x ", omega[i]);
	}
	printf("\n");

	for(i = 0; i < CODEWORD_LEN; i++)
	{
		lambda_root = 0xFF;
		for(j = 0; j < (CODEWORD_LEN - MESSAGE_LEN) / 2 + 1; j++)
		{
			lambda_root = gf_add(lambda_root, gf_multp(lambda[j], j * power_polynomial_table[i + 1][0]));
			//printf("%d %d: %x %x %x\n", i, j, lambda_root, lambda[j], j * power_polynomial_table[i + 1][0]);
		}
		//printf("%d: %x %x\n", i, lambda_root, power_polynomial_table[i + 1][0]);
		if(0xFF == lambda_root)
		{
			err_location[i] = 1;
		}
	}
	printf("Error Location:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", err_location[i]);
	}
	printf("\n");

	/*derivative of lambda*/
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2; i++)
	{
		if(0 != ((i + 1) % 2))
		{
			lambda_dev[i] = lambda[i + 1];
		}
	}
	printf("Lambda Derivative Polynomial:\n");
	for(i = 0; i < (CODEWORD_LEN - MESSAGE_LEN) / 2; i++)
	{
		printf("%x ", lambda_dev[i]);
	}
	printf("\n");

	/*magnitude of error*/
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		if(0 == err_location[i])
		{
			continue;
		}
		else
		{
			tmp = 0xFF;
			for(j = 0; j < (CODEWORD_LEN - MESSAGE_LEN) / 2 + (CODEWORD_LEN - MESSAGE_LEN - 1) / 2 + 1; j++)
			{
				//printf("%d %d: %x %x %x %x\n", i, j, tmp, omega[j], j * power_polynomial_table[i + 1][0], gf_multp(omega[j], j * power_polynomial_table[i + 1][0]));
				tmp = gf_add(tmp, gf_multp(omega[j], j * power_polynomial_table[i + 1][0]));
			}
			tmp_sum = 0xFF;
			for(j = 0; j < (CODEWORD_LEN - MESSAGE_LEN) / 2; j++)
			{
				//printf("%d %d: %x %x %x %x\n", i, j, tmp_sum, lambda_dev[j], j * power_polynomial_table[i + 1][0], gf_multp(lambda_dev[j], j * power_polynomial_table[i + 1][0]));
				tmp_sum = gf_add(tmp_sum, gf_multp(lambda_dev[j], j * power_polynomial_table[i + 1][0]));
			}
			//printf("%d: %x %x\n", i, tmp, tmp_sum);
			err_mag[i] = gf_div(tmp, tmp_sum);
		}
	}
	printf("Error Magnitude:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", err_mag[i]);
	}
	printf("\n");
	
	return 0;
}
